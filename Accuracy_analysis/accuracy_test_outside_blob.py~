import cv2
import numpy as np
import pickle
import matplotlib.pyplot as plt
from marker_detection_functions import detect_circles_blob, detect_aruco_pose, detect_crosses, get_subpixel_centers_corner, get_subpixel_centers_gaussian
from visualization import show_frame, zoom_in_on_circle
from Triangulation_and_matching import triangulate_points, sort_markers_gridwise
from plotting_utils import plot_3d, plot_3d_with_distances, transform_to_aruco_frame
# === CONFIG ===
calib_file = "../Calibration/stereoscopic_calibration/stereo_calibration_wide_72cm.pkl"

# === LOAD STEREO CALIBRATION ===
with open(calib_file, "rb") as f:
    calib = pickle.load(f)

mtx1 = calib["camera_matrix_1"]
dist1 = calib["dist_coeffs_1"]
mtx2 = calib["camera_matrix_2"]
dist2 = calib["dist_coeffs_2"]
R = calib["R"]
T = calib["T"]

print(f"R: {R} and T: {T}")

# === MAIN PIPELINE ===1
left = cv2.imread("72_cm_baseline/left camera/frame_0003_wide_4m.jpg")
right = cv2.imread("72_cm_baseline/right camera/frame_0003_wide_4m.jpg")

h, w = left.shape[:2]
image_size = (w, h)

# === Stereo Rectification ===
R1, R2, P1, P2, Q, _, _ = cv2.stereoRectify(
    mtx1, dist1, mtx2, dist2,
    image_size,
    R, T,
    flags=cv2.CALIB_FIX_INTRINSIC,
    alpha=0
)

def to_cv2_pts(points):
    return [(float(p[0]), float(p[1])) for p in points]


# ============ Undistortion and Rectification Maps ============
map1x, map1y = cv2.initUndistortRectifyMap(mtx1, dist1, R1, P1, image_size, cv2.CV_32FC1)
map2x, map2y = cv2.initUndistortRectifyMap(mtx2, dist2, R2, P2, image_size, cv2.CV_32FC1)

left = cv2.remap(left, map1x, map1y, cv2.INTER_LINEAR)
right = cv2.remap(right, map2x, map2y, cv2.INTER_LINEAR)

left_copy = left.copy()
right_copy = right.copy()


# ============ DETECTION ==============
blue_left, _ = detect_circles_blob(left, "blue")
blue_right, _ = detect_circles_blob(right, "blue")
blue_left_centers = get_subpixel_centers_gaussian(left, blue_left)
blue_right_centers = get_subpixel_centers_gaussian(right, blue_right)

crosses_left, _ = detect_crosses(left)
crosses_right, _ = detect_crosses(right)



# ============= SORTING MARKERS ===========
blue_left_sorted = sort_markers_gridwise(blue_left_centers)
blue_right_sorted = sort_markers_gridwise(blue_right_centers)
n_blue = min(len(blue_left_sorted), len(blue_right_sorted))
blue_left_filt = blue_left_sorted[:n_blue]
blue_right_filt = blue_right_sorted[:n_blue]

crosses_left_sorted = sort_markers_gridwise(crosses_left)
crosses_right_sorted = sort_markers_gridwise(crosses_right)
n_cross = min(len(crosses_left_sorted), len(crosses_right_sorted))
crosses_left_filt = crosses_left_sorted[:n_cross]
crosses_right_filt = crosses_right_sorted[:n_cross]


# ================== TRIANGULATION ==============
blue_left_pts = to_cv2_pts(blue_left_filt)
blue_right_pts = to_cv2_pts(blue_right_filt)
blue_3d = triangulate_points(blue_left_pts, blue_right_pts, P1, P2)

crosses_left_pts = to_cv2_pts(crosses_left_filt)
crosses_right_pts = to_cv2_pts(crosses_right_filt)
cross_3d = triangulate_points(crosses_left_pts, crosses_right_pts, P1, P2)


# ================= ARUCO DETECTION & TRANSFORMATION ===========
corners_l, rvec_l, tvec_l = detect_aruco_pose(left, mtx1, dist1)
corners_r, rvec_r, tvec_r = detect_aruco_pose(right, mtx2, dist2)

if corners_l is not None and rvec_l is not None and tvec_l is not None:
    cv2.aruco.drawAxis(left, mtx1, dist1, rvec_l, tvec_l, 1)

if corners_r is not None and rvec_r is not None and tvec_r is not None:
    cv2.aruco.drawAxis(right, mtx2, dist2, rvec_r, tvec_r, 0.5)

# Apply transformation to ArUco frame
if tvec_l is not None:
    blue_3d_aruco = transform_to_aruco_frame(blue_3d, rvec_l, tvec_l)
    cross_3d_aruco = transform_to_aruco_frame(cross_3d, rvec_l, tvec_l)


# ============== SHOW FRAMES WITH IDENTIFIED MARKERS ================
left = show_frame(left, blue_left_sorted, crosses_left_filt)  # No copy here
right = show_frame(right, blue_right_sorted, crosses_right_filt)  # No copy here

fx = fy = 0.5
cv2.imshow("Left Image with ArUco, Circles, Crosses", cv2.resize(left, None, fx=fx, fy=fy))
cv2.imshow("Right Image with ArUco, Circles, Crosses", cv2.resize(right, None, fx=fx, fy=fy))

cv2.waitKey(0)
cv2.destroyAllWindows()


for i, circle in enumerate(blue_left_sorted):
    # Extract a close-up of the circle
    zoomed_in_image = zoom_in_on_circle(left_copy, circle)
    zoomed_in_image=cv2.resize(zoomed_in_image, (zoomed_in_image.shape[1] * 10, zoomed_in_image.shape[0] * 10))
    # Display the zoomed-in image
    cv2.imshow(f"Zoomed-In Circle right {i + 1}", zoomed_in_image)

for i, circle in enumerate(blue_right_sorted):
    # Extract a close-up of the circle
    zoomed_in_image = zoom_in_on_circle(right_copy, circle)
    zoomed_in_image=cv2.resize(zoomed_in_image, (zoomed_in_image.shape[1] * 10, zoomed_in_image.shape[0] * 10))
    # Display the zoomed-in image
    cv2.imshow(f"Zoomed-In circle left {i + 1}", zoomed_in_image)

cv2.waitKey(0)
cv2.destroyAllWindows()


# ============== PLOTTING ================

#plot_3d_with_distances(blue_3d, "Blue Circles with Distance Lines")
#plot_3d_with_distances(blue_3d_aruco, "Blue Circles in Aruco with distance lines")
plot_3d_with_distances(cross_3d, "Crosses with distance lines")
#plot_3d_with_distances(cross_3d_aruco, "Crosses in Aruco with distance lines")

